# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FloodingAnalyzer
                                 A QGIS plugin
 Simulation de submersion
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-14
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Sanchez, Roland
        email                : sanchez.matteopro@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.core import *
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from collections import defaultdict
import matplotlib.pyplot as plt
import os
import csv
import processing

from .Modele_inondation import Modele_inondation

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .FloodingAnalyzer_dialog import FloodingAnalyzerDialog
import os.path


class FloodingAnalyzer:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'FloodingAnalyzer_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&FloodingAnalyzer')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('FloodingAnalyzer', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/FloodingAnalyzer/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'FloodingAnalyzer'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&FloodingAnalyzer'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = FloodingAnalyzerDialog()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Récupération des couches et des paramètres d'entrée depuis l'interface
            couche_bati = self.dlg.mMapLayerComboBox_bati.currentText()
            couche_pop = self.dlg.mMapLayerComboBox_pop.currentText()
            couche_OCS = self.dlg.mMapLayerComboBox_OCS.currentText()
            couche_coursEau = self.dlg.mMapLayerComboBox_coursEau.currentText()
            couche_decoupe=self.dlg.mMapLayerComboBox_masque.currentText()
            couche_MNT = self.dlg.mMapLayerComboBox_MNT.currentText()
            Hauteur_sub = self.dlg.lineEdit_hSub.displayText()
            Zone_tampon = self.dlg.lineEdit_ZT.displayText()

            # Demander à l'utilisateur de sélectionner un dossier de sortie
            chemin_acces = QFileDialog.getExistingDirectory(None,
                                                            "Sélectionnez un dossier pour enregistrer les résultats")
            if not chemin_acces:
                self.iface.messageBar().pushMessage("Erreur", "Aucun dossier sélectionné.", level=3)
                return

            # Récupération des couches par nom
            layer1, layer2, layer3, layer4, layer5, layer6 = None, None, None, None, None, None
            for layer in QgsProject.instance().mapLayers().values():
                if layer.name() == couche_bati:
                    layer1 = layer
                if layer.name() == couche_pop:
                    layer2 = layer
                if layer.name() == couche_OCS:
                    layer3 = layer
                if layer.name() == couche_coursEau:
                    layer4 = layer
                if layer.name() == couche_MNT:
                    layer5 = layer
                if layer.name() == couche_decoupe:
                    layer6 = layer 

            # Vérifiez que toutes les couches sont bien présentes
            if None in [layer1, layer2, layer3, layer4, layer5, layer6]:
                self.iface.messageBar().pushMessage("Erreur", "Une ou plusieurs couches sont manquantes.", level=3)
                return


        
            # Initialisation du modèle et des paramètres de traitement
            self.modele = Modele_inondation()
            feedback = QgsProcessingFeedback()
            context = QgsProcessingContext()

            # Extraction des chemins des sources de couches
            pathCoucheBati = layer1.source()
            pathCouchePop = layer2.source()
            pathCoucheOCS = layer3.source()
            pathCoucheCoursEau = layer4.source()
            pathCoucheMNT = layer5.source()
            pathCoucheDecoupe = layer6.source()
            VHauteur_sub = int(Hauteur_sub)
            VZone_tampon = int(Zone_tampon)


            # Définir les chemins de sortie dans le dossier choisi
            pathresultBati = os.path.join(chemin_acces, "Bati_final.shp")
            pathresultPop = os.path.join(chemin_acces, "Pop_final.shp")
            pathresultOcs = os.path.join(chemin_acces, "OCS_final.shp")
            pathresultMNT = os.path.join(chemin_acces,"MNT_final.tiff")


            # Paramètres pour le modèle
            parameters = {
                'bd_topo': pathCoucheBati,
                'population': pathCouchePop,
                'ocs': pathCoucheOCS,
                'hydro': pathCoucheCoursEau,
                'mnt': pathCoucheMNT,
                'hauteur_submersion': VHauteur_sub,
                'buffer_terre': VZone_tampon,
                'Pop_final': pathresultPop,
                'Bati_final': pathresultBati,
                'Ocs_final': pathresultOcs,
                'couche_decoupe' : pathCoucheDecoupe,
                'Mnt_final' : pathresultMNT
            }

            # Exécution de l'algorithme de traitement
            self.modele.initAlgorithm()
            self.modele.processAlgorithm(parameters, context, feedback)

            # Chargement des résultats dans le projet QGIS
            vlayer1 = QgsVectorLayer(pathresultBati, 'Bati_final', 'ogr')
            vlayer2 = QgsVectorLayer(pathresultPop, 'Pop_final', 'ogr')
            vlayer3 = QgsVectorLayer(pathresultOcs, 'OCS_final', 'ogr')
            vlayer4 = QgsRasterLayer(pathresultMNT,'MNT_finale')




            QgsProject.instance().addMapLayer(vlayer1)
            QgsProject.instance().addMapLayer(vlayer3)
            QgsProject.instance().addMapLayer(vlayer2)
            QgsProject.instance().addMapLayer(vlayer4)

            # Confirmation visuelle de la création des résultats
            self.iface.messageBar().pushMessage("Succès", "Les résultats ont été enregistrés dans : " + chemin_acces,
                                                level=1)

            # Donnees tableau csv
            nb_bati = vlayer1.featureCount()
            nb_pop = count_individus_return()


            
            calculate_area_by_category()

            # POURCENTAGE ZONE INONDEE

            # Appel de la fonction
            count_individus()

            # Appel de la fonction
            calculate_inundated_area_percentage(layer3)

            creation_csv(self, nb_bati, nb_pop)

def calculate_area_by_category():
            # Récupère la couche Ocs_final par son nom dans le projet
    layer = QgsProject.instance().mapLayersByName('OCS_final')[0]

            # Vérifie que la couche a bien été trouvée et que le champ 'libelle_fr' existe
    if layer is None or layer.fields().indexFromName('libelle_fr') == -1:
         QMessageBox.warning(None, "Erreur", "La couche 'Ocs_final' ou le champ 'libelle_fr' n'existe pas.")
    return

            # Dictionnaire pour stocker la superficie totale de chaque catégorie
    areas_by_category = defaultdict(float)

            # Parcourt chaque entité de la couche
    for feature in layer.getFeatures():
                # Récupère la valeur du champ 'libelle_fr'
        category = feature['libelle_fr']

                # Calcule la superficie en km²
        area_km2 = feature.geometry().area() / 1000000  # Conversion de m² en km²

                # Additionne la superficie dans le dictionnaire pour la catégorie correspondante
        areas_by_category[category] += area_km2

            # Affiche les résultats
        #results = "\n".join([f"Catégorie '{cat}': {area:.2f} km²" for cat, area in areas_by_category.items()])
        #QMessageBox.information(None, "Superficie par catégorie", results)

            # Préparation des données pour le graphique
    categories = list(areas_by_category.keys())
    areas = list(areas_by_category.values())

            # Création du graphique en camembert
    plt.figure(figsize=(8, 8))
    plt.pie(areas, labels=categories, autopct='%1.1f%%', startangle=140)
    plt.title("Répartition des superficies par catégorie (en km²)")
    plt.axis('equal')

    plt.show()

def count_individus_return():
            # Récupère la couche Pop_final par son nom dans le projet
    layer = QgsProject.instance().mapLayersByName('Pop_final')[0]

            # Initialisation du compteur pour le nombre total d'individus
    total_ind = 0

            # Parcourt chaque entité de la couche et additionne les valeurs du champ 'Ind'
    for feature in layer.getFeatures():
        ind = feature['Ind']

                # Vérifie que la valeur n'est pas nulle ou manquante
        if ind is not None:
            total_ind += ind

            # Affiche le résultat dans une boîte de message
    return total_ind

def count_individus():
# Récupère la couche Pop_final par son nom dans le projet
    layer = QgsProject.instance().mapLayersByName('Pop_final')[0]

# Initialisation du compteur pour le nombre total d'individus
    total_ind = 0

# Parcourt chaque entité de la couche et additionne les valeurs du champ 'Ind'
    for feature in layer.getFeatures():
        ind = feature['Ind']
    # Vérifie que la valeur n'est pas nulle ou manquante
        if ind is not None:
            total_ind += ind

        # Affiche le résultat dans une boîte de message
    QMessageBox.information(None, "Total des Individus", f"Nombre total d'individus : {total_ind}")




def calculate_inundated_area_percentage(layer_OCS):
            # Recherche de la couche 'Ocs_final' dans le projet
    layers_Ocs_final = QgsProject.instance().mapLayersByName('OCS_final')

            # Vérifie que les couches ont été trouvées
    if layer_OCS is None:
        QMessageBox.warning(None, "Erreur", "La couche 'couche_OCS' n'a pas été trouvée dans le projet.")
        return
    if not layers_Ocs_final:
        QMessageBox.warning(None, "Erreur", "La couche 'Ocs_final' n'a pas été trouvée dans le projet.")
        return

            # Récupère la première (et unique) couche 'Ocs_final' de la liste
    layer_Ocs_final = layers_Ocs_final[0]

            # Calcul de la superficie totale de 'couche_OCS' en km²
    area_OCS = sum([feature.geometry().area() for feature in layer_OCS.getFeatures()]) / 1000000

            # Calcul de la superficie totale de 'Ocs_final' en km²
    area_Ocs_final = sum([feature.geometry().area() for feature in layer_Ocs_final.getFeatures()]) / 1000000

            # Vérifie que la superficie de 'couche_OCS' n'est pas nulle pour éviter une division par zéro
    if area_OCS == 0:
        QMessageBox.warning(None, "Erreur", "La superficie de la couche 'couche_OCS' est nulle.")
        return

            # Calcul du pourcentage de zone inondée
    inundated_percentage = (area_Ocs_final / area_OCS) * 100

            # Affiche le résultat dans une boîte de message
    QMessageBox.information(None, "Pourcentage de Zone Inondée",
                                    f"Pourcentage de zone inondée : {inundated_percentage:.2f}%")

def creation_csv(self, nb_bati, nb_pop):
            # Demander à l'utilisateur de choisir l'emplacement pour enregistrer le fichier CSV
    csv_file_path, _ = QFileDialog.getSaveFileName(None, "Enregistrer le fichier CSV", "", "CSV Files (*.csv)")

            # Vérifie si l'utilisateur a bien sélectionné un chemin pour enregistrer le fichier
    if not csv_file_path:
        self.iface.messageBar().pushMessage("Erreur",
                                                    "Aucun fichier n'a été sélectionné pour l'enregistrement.",
                                                    level=3)
        return

            # Ajoute l'extension .csv si elle n'est pas présente
    if not csv_file_path.endswith(".csv"):
        csv_file_path += ".csv"

            # Données à écrire dans le fichier CSV
    data = [
        ["Simulation de", "Valeur"],
        ["Batiment impactes", nb_bati],
        ["Individus impactes", nb_pop]
    ]
            # Ecriture des données dans le fichier CSV
    try:
        with open(csv_file_path, 'w', newline='', encoding="utf-8") as csvfile:
            writer = csv.writer(csvfile)
            writer.writerows(data)

                # Confirmation de l'enregistrement
        self.iface.messageBar().pushMessage("Succès",
                                                    f"Les données ont été enregistrées dans : {csv_file_path}", level=1)

        QMessageBox.information(None, "Information",
                                        f"Le fichier CSV a bien été enregistré au chemin suivant :\n{csv_file_path}")

    except IOError as e:
        self.iface.messageBar().pushMessage("Erreur", f"Erreur lors de l'écriture du fichier : {str(e)}",
                                                    level=3)


    